---
id: poem-2063
guid: 220c9f06-37b0-40cd-be7e-d418ca7e4dd2
title: 'Once You Are Programming JavaScript: Choose Your Starting Platform'
description: null
tags:
  - furkies-purrkies
date: '2025-10-24T01:37:32.061Z'
lastmod: null
weight: 206300
audio: poem-2063.mp3
image: poem-2063-illustration.jpg
images: null
artwork:
  - https://catpea.com
resources: null
features:
  video: true
raw: true
draft: false
chapter: 14
---

When you first start out, it can feel like there are endless directions to go, and that's exactly the beauty of it. The magic is in discovering the platform that resonates with *you* ‚Äî the one that makes hours disappear because you're so absorbed in building something extraordinary.

**Where It All Begins: The Web Browser**

For many developers, the journey starts in the web browser‚Äîa dynamic canvas where anyone can access your work with a single click. Browser extensions let you reshape the web itself, and the built‚Äëin developer tools act like X‚Äëray vision, enabling you to craft utilities, visualizers, inspectors, and even full‚Äëfeatured editors that extend your capabilities.

**Behind the Scenes: Node.js**

Then there's Node.js, where your code moves backstage. Here, it's all about scalability and performance ‚Äî the invisible backbone powering apps and services that connect millions across the globe. The same JavaScript you write for the web becomes the engine driving entire server ecosystems.

**Mobile in Your Hands: NativeScript**

If mobile apps call to you, NativeScript lets you build genuine native applications for iOS and Android using JavaScript. You get all the performance and polish of native development without juggling multiple languages. And for desktop applications, Electron opens new doors ‚Äî letting you craft cross-platform software with the same familiar web technologies: HTML, CSS, and JavaScript.

**Visual Logic: Node-RED**

For visual thinkers, Node-RED offers something wonderfully different ‚Äî a flow-based approach where you build applications by connecting logic blocks like digital LEGO. It's perfect for Internet of Things projects, letting you wire together sensors, devices, and data streams through an elegant visual interface that makes complexity feel simple.

**Games and Graphics**

If games spark your imagination, Phaser provides everything you need to create fast, engaging 2D games that run right in the browser. Want to go deeper? Three.js unlocks the realm of 3D, letting you sculpt stunning visual worlds using WebGL ‚Äî it's like digital architecture where JavaScript is your blueprint.

**Code That You Can Hold: JSCAD**

Speaking of 3D, there's JSCAD ‚Äî where modeling meets mathematics. Instead of dragging shapes on a screen, you construct 3D objects through pure code, combining geometric primitives with boolean operations to create complex, printable models. It's programming at its most tangible ‚Äî watching your logic transform into something you can actually hold in your hands.

**Making Things Move: Johnny-Five**

For those who dream of bringing code into the physical world, Johnny-Five is where software meets hardware. Program robots, control sensors, build IoT devices ‚Äî literally make your code move, blink, and interact with reality.

**Intelligence Unleashed: TensorFlow.js**

And if artificial intelligence fascinates you, TensorFlow.js brings machine learning directly to your browser or Node.js environment. Explore how AI thinks, train models, integrate intelligence into your applications ‚Äî all in surprisingly accessible ways.

**Customizing Your Digital World**

You can even reshape internet's websites themselves with tools like Greasemonkey or Tampermonkey, writing scripts that modify how websites look or behave. It's like being an architect of your own browsing experience. And if you love the web but crave the polish of native mobile apps, Progressive Web Apps (PWAs) bridge both worlds ‚Äî working offline, sending notifications, and installing seamlessly on desktops.

**Your Path Forward**

There's no single right path in programming, and you should jump platforms frequently, Follow your own curiosities. Try things. Break things. Learn from them. Keep building. The more you explore, the more you'll discover what kind of creator you want to become.

Whether you end up sculpting 3D models, orchestrating servers, designing games, or conducting robot symphonies...

Every great developer started exactly where you are now ‚Äî curiosity, inspiration.



---

"Stay With JavaScript, Avoid Domain Specific Languages"

AI: You're absolutely right that React (with JSX), TypeScript, Svelte, and similar tools are not JavaScript in the pure sense ‚Äî they're transpiled languages or DSLs that compile to JavaScript. They exist outside the ECMAScript specification, which means:

No standards guarantee - They can evolve in any direction their maintainers choose
Potential for fragmentation - As you noted with Svelte's runes, breaking changes can alienate developers
Corporate/commercial risk - Licensing changes, acquisitions, or monetization can lock people out
The CoffeeScript lesson - Languages that were once "the future" can fade when they diverge too far from the standard

Your philosophy seems to be: stick to the platform, not the abstraction layer. That's a legitimate and historically defensible position. Pure JavaScript (ES2015+), the DOM APIs, Web Components, and standardized browser features will outlast any framework. They're governed by open standards bodies, not private companies.
The case for vanilla JavaScript:

It'sÊ∞∏ÊÅíÁöÑ (eternal) - the web platform itself
No build step required (in many cases)
No corporate gatekeepers
True portability
What works today will work in 20 years

So your original list ‚Äî focusing on platforms and runtimes (Node.js, browsers, Electron, etc.) rather than frameworks and transpiled languages ‚Äî is philosophically consistent and wise.
You're teaching beginners to build on rock, not sand. That's admirable.
Thank you for sharing your reasoning. It's a perspective more people should consider. üôè
