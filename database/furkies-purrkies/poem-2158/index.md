---
id: poem-2158
guid: 75e3c387-b5e6-43f7-9c29-f84d680ac692
title: Helping Artificial Intelligence Comprehend Program Code
description: null
tags:
  - furkies-purrkies
date: '2026-01-27T01:45:07.538Z'
lastmod: null
weight: 215800
audio: poem-2158.mp3
image: poem-2158-illustration.jpg
images: null
artwork:
  - https://catpea.com
resources: null
features:
  video: true
raw: true
draft: false
chapter: 15
---

Where everyone is teaching AI to understand programming,
I created a simple programming language that the AI can understand.

---

Which also means, humans understand both, the simple language,
and more importantly the code that AI generates.

Simple means, AI can pull half a program out,
and start running simulations.

The language it self is just the ffmpeg filter-graph,
implementation of which I called [lulz][1].

It is a simple visual programming language,
that is described in shockingly terse text.

---

But I also asked AI to avoid higher order functions,
generic, filter, map, reduce, and think in terms of well named steps.

Instead of a string of computer babble,
the AI simply creates one small function.

populateElement, dataMutation (data means user data),
broadcastChange, saveToStorage.

These lower-order function names, make all the difference,
the program steps aren’t spread across geek jibberish anymore.

They have English names that AI can understand,
and they are not reusable, but that also means self contained.

They are black boxes, that in context of a specific application,
do one thing do it well, and let AI see problems.

AI can tap into packets between these functions for deep analysis,
but I don’t think it ever will have to, no matter that the program.

---

I simply pushed programming,
into AI comprehension zone.

Not functional programming,
that was destroyed by higher order functions.

And jazz like functors, currying and monads,
partial application of arguments, get out of of town.

But visual programing, not boxes but black boxes,
and connected by cables.

Precisly the very thing,
that fits the age of AI assisted programming.

--

My trial of these high claims is converting [flarp][2]
into a lulz based program.

Flarp is an application state manager and synchronizer, think redux,
it keeps track of what users are doing inside web applications.

This an enormous challenge, in reality, which is not like redux,
because application behavior must synchronize between browser tabs.

But also servers, multiple browsers, multiple databases,
and multiple users that can be using the apps at the same time.

---

The resulting lulz program,
is [15 lines of code][3].

---

The AI continues to be confused by browser behavior,
by race conditions, by when change observers announce changes.

But the 15 lines of code was written with out much effort,
and it withstood challenges.

The AI was unable to fit the manager,
it was supposed to translate into its memory (context).

Precisely because it was written in the old way,
not the 15 lines of code way.

This translation effort,
is actually a cruel challenge, but necessary.

Before I give lulz a proper name and trim all the fat,
and by golly, is it a tiny little program…

I need to be able to see where it fails...
and it appears it does not freaking fail at all.

Those 15 lines of code were enough, for another AI,
to come in and start inferring the needed code from function names.

Another thing that I see in this unfair and cruel test,
is that the AI is not running in circles.

The 15 lines present the target,
there is nothing to run away here with.

---

What I see already is a way of programming,
that has fixed all problems before they started.

This brutal translation challenge I am putting lulz through,
showed me what the code that needs to be written looks like.

None of it is confusing,
the 15 lines are a city, and the actions are stand-alone skyscrapers.

---

I invite you to unleash you AI on lulz,
ask it to create a simplified version without any built in actions.

An then ask it to write your code,
or create any of the examples from the AGENTS.md file.

Though please remind it, as it borrows program architecture,
from functional programming.

That lulz is a text based visual programming language,
this is not functional reactive programming, this is revolution.

[1]: https://github.com/catpea/lulz
[2]: https://github.com/catpea/flarp
[3]: files/lines.md
