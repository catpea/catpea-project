Egon teaches us not to cross the particle streams,
and this could not be more true in the world of ghost busing.

But in the world of programming,
crossing the streams is one of the finest things you can do.

It ignites recursion,
and spews out all kinds of colorful fractals everywhere.

You should already be creating programs out of thin air,
connecting EventEmitters and and massive trees that only require 4 lines of code.

And at this point, when you connect things to themselves,
you get a sum that is significantly more than its parts.

---

The program concept behind wikipedia creates only one page,
that can have links, to it self, with one difference, the article name.

That is all it takes to map out all human knowledge,
and get excited about training AI to just grok the shape of things.

---

Let us leave the world of simple things behind,
and forget that a number is just a numeric value.

And instead lets think in objects.
An object is a collection of values.

The same way that a Folder,
is a collection of things, mostly files, but nested folders as well.

We need to get behind numbers and upgrade them,
because for a powerful programmer a number must be more than a value.

They must have a change monitoring mechanism,
often called an observer.

For example, we create an object called number,
and give it a getter and a setter function for value.

Getter just gets the number, via MyNumber.value
but setter, is special.

Because when you say myNumber.value = 5,
setter will not only remember the new value…

But also notify all the value observers,
and this is a big deal, as it means auto-magical updates throughout your application.

So you no longer just say X = A+B,
you also add A.observe() with a function of X=V+B.

Where V, is the new value that was just assigned,
and you can use the .value as well, it is just that .observe gives you a copy along with the notification.

---

Finally, let’s jump to a powerful program example,
you are working with a visual programming language.

And you discover that you need a new data type for color,
so it is just like number, except here we store a number that represents a color.

And since this is a visual language, you can throw in a color picker,
a pretty big deal, when designing graphic themes for applications.

So, you save your own program,
and go into the system node of your programming language.

Open up the toolbox, and data category,
use a text data type as base, call it as color.

And drag a connector to the data category node,
and instantly a new data type appears in your visual programming language.

That is the power of Reactive Programming, of observing values,
on building on top of reactive sub systems.

Before you decorate it to have all the features you need,
you decide, that you don’t like your data types being sorted by label.

Because the color data type will now appear before String Text and Number,
so you drop in a sort node, and rather than messing around with an order field.

You tell it to sort based on the .y property of you visual nodes,
now as you move your data type boxes, to make number first and color on bottom.

Your toolbox for the data type,
automatically reflects those values.

Now you can go back to your own program,
and drop the color data type in there.

The biggest stream crossing s that the visual programming language,
is made with it self, and thus self editable.

Just imagine the community of hackers that will assemble here,
replacing everything and sharing their inventions.

But there is more, because rather than generating code for your program,
and detaching it from the visual programming language.

You just open an overlay on top, and put a little PI symbol in the corner,
now your users can edit both the application and the environment.

They don’t have to worry about hunting for things that need update,
when a change is made, as everything is reactive.

Software today is not just broken, buggy and complex,
it is a fossil a primitive first try.

The world of programming is ready for more,
and visual reactive programming is less complex that a hard game.

For one, no node will chase you, or try to eat you,
unless of course, you program it that way…
