---
id: poem-1123
guid: d89f34b1-7ae7-45a9-ac49-b9164889915f
title: Simple And Lightweight Code
description: null
tags:
  - furkies-purrkies
date: '2023-03-30T03:21:07.857Z'
lastmod: null
weight: 112300
audio: poem-1123.mp3
image: poem-1123-illustration.jpg
images: null
artwork:
  - https://www.pexels.com/photo/person-working-remotely-3987066/
resources: null
features:
  video: false
raw: true
draft: false
chapter: 6
---

When you make your modules tiny,
your code-base will become shiny.

So as long as you know what comes next,
programming is not complex.

Corporate programming is twisted,
you should write for yourself instead.

Build a tiny little outfit,
and let it work to your own benefit.

Ineffective education will take your money,
and your corporate job is not a nanny.

They’ll replace you as soon as they can,
they want a robot not a human.

---

When programming on your own,
you are always in the zone.

Like you can’t really learn what you are told,
you can’t write code just to be sold.

Your own programs pretty,
you are after all building a tiny city.

To make sure all the streets connect,
you have to be the lone architect.

---

The process of writing your code,
must also be a simple road.

You can’t jump in the middle,
or the code base turns into a riddle.

Once you have everything planned,
you start writing a simple OS command.

You add a few more,
to create a solid floor.

And code a tiny reverse proxy like server,
as a uniform API surface is a time saver.

You must use tables for your data,
as these will quickly move you out of beta.

The column names must be a work of art,
keep your database tidy and smart.

Make a new HTTP server for GUI,
but think of it as client to your API.

Build many clients as you experiment,
code all kinds of ways to your merriment,

---

Know that our universe is a tree,
everything is a nested category.

To put that in a table think in edges and nodes,
and you will never run out of roads.

Write more commands to manage your tree,
keep your components loose and free.

Think of your app as living in a desktop,
and give it a command to start and stop.

Think of the strange desktop your root,
and you can listen to branch changes to boot.

---

UI state management is impossibly hard,
and you have to stay on guard.

Best way is to give your users a tiny DB,
and then synchronize tables in a way you can see.

But synchronization conflicts will arise,
so distributes state is neat but not very wise.

If you just hammer one source of truth,
you won’t waste your time or youth.

Make backups but have those CPU cores glow red,
and make sure the database never goes dead.

Keep the code lightweight,
and keep writing simple commands and automate.

---

To practice for success,
begin by writing a WikiWiki without stress.

And allow code to execute in articles,
think of it as system particles.

You are making a code editor, always a win,
and beneath crafting a secure little code bin.

Now your code-base is comments first,
and your app code won’t be cursed.

Now let your articles nest,
and create a universe as a test.

Now you can work on a hundred apps,
and easily generate their maps.

---

This is your laboratory,
and the beginning of your story.

Only in experiment can you find your app,
and divide winners from scrap.

Remember to use simple commands and a nested tree,
so that your vision is never obscured and you can see.

It is an ancient philosophy that works really well,
so you might as well give your commands a shell.
