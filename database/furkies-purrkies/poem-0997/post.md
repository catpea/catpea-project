A self referential system, is something that curves on it self,
and creates new things out of nothing.

Imagine a WikiWiki program like the world encyclopedia,
and notice how the side menus are editable articles too.

And consider that the layouts are editable articles,
server configuration is editable from the web if you have the right password.

---

And all it really is under the hood, is a web-page,
with a edit button.

And the text you are editing has special little syntax,
that is not part of normal English.

When you put, for example, the word include, followed by article name, in square brackets,
that article will end up being pulled into your page.

You can just about make anything this way,
including an infinite loop.

Where you include the article you are editing,
into it self.

---

If you are going to be programming such a system,
infinite loops like this, are a great place for Easter Eggs.

An Easter egg is a funny or secret part of a program,
if I was working on this part of a system.

I would make a chat-bot talk to it self,
so it would be like Eliza1 talking to Eliza2.

I'd make them philosophize,
for days.

---

WikiWikis are amazing, they are almost completely unexplored,
the surface has hardly been scratched by the chickens.

Consider creating a WikiWiki for programming applications,
you start a new page, list out the things you need...

Set a monetary bounty on each item,
anf get an alert when they are done, or need to pay more.

Here users with basic programming skills would be coding,
actions, commands or functions...

You know, input in, output out,
and when done you have your program.

---

SO the WikiWiki is not a trivial example,
a code WikiWiki structured to function like the Apple Automator is the bees knees.

---

But self referential programming,
is not some mysterious thing meant for self referential, distributed, collaborative, wikis.

It is actually one of the first things you learned about,
when you first begun using a computer.

It just isn't entirely clear,
because operating systems stopped innovating.

Plan9 an experimental Open Source Operating System,
shows where Operating Systems could have gone.

In that type of a system everything is a file,
if you want to download a picture file.

You go to the internet folder,
and open a file that is named after the link that you are trying to download.

And after a while, when the download completes,
that image will open up in your image viewer.

Everything is a file, the speed of the CPU, all the UNDOs in the text you are writing,
even the screen over at your workplace is an image file, or a video, everything is a file.

---

But a more familiar example, is the file manager on your desktop computer,
here files and directories, are used over an over and every which way...

To create multitudes of things,
and if you stick the concept of file-systems, directories, and files, on the bottom of the programs you write.

Then you will have a usable application,
long before you create a settings pane, or user profile editor, or even the home-page dashboard editor.

By using the concept of files and folders for your application data structures,
all you need to start managing everything, is a file manager.

Title image is [Baron Munchausen pulling himself out of a mire by his own hair][1], wrapped by the [Ouroboros symbol][2].

[1]: https://en.wikipedia.org/wiki/Baron_Munchausen
[2]: https://en.wikipedia.org/wiki/Ouroboros
