---
id: poem-2143
guid: 05cdfeea-541c-4284-b299-b353b9d78e4e
title: 'Flow Based Programming: Push And Pull - Super Easy JavaScript'
description: null
tags:
  - furkies-purrkies
date: '2026-01-12T03:06:17.778Z'
lastmod: null
weight: 214300
audio: poem-2143.mp3
image: poem-2143-illustration.jpg
images: null
artwork:
  - https://catpea.com
resources: null
features:
  video: true
raw: true
draft: false
chapter: 15
---

You need to start selling AI services,
AI is not chat or photos, it is an infinite complexity machine.

But, your users will be sending requests in faster,
than your AI will be able to process them.

Industry nerds and college taught,
will talk about software applications here.

But the truth is,
you can handle it all in 15 lines of code.

---

You can’t tell the users when to do business,
they will always push, and that means you will queue their AI requests.

But, when it comes to processing those requests,
you have to pull.

Because you need to wait for your local AI to finish the current job,
before you can send the next one in.

---

Here is the crazy part,
push is a normal computer function with an extra argument.

And pull, is an almost normal computer for loop,
it is an asynchronous loop, just another extra argument.

With two freaking words,
standard programming, into a wise living pipeline.

That not only wisely performs your computations,
and in a way that is friendly to multiple CPU cores.

As you can have as many programs pulling from the queue,
as you have CPU cores.

But also flow based programming,
is a tree of little functions, not necessarily reusable, but certainly necessary.

---

So what are those two words, in the push system,
where we can’t control incoming data.

The word is send, the program that organizes our tree,
about 10 lines of code in size.

Makes it so, that the send function,
will send data to the next functions that follow.

Just that send,
creates a push directed flow based programming system.

And once you have transformed you data,
you stick a log file at the end, that is your data queue.

This is where all those unrelenting requests pile up,
this is your request warehouse.

And from here, you switch to pull architecture,
you say for await request in queue,

And the for loop give you your first request,
and here you say await aiProcess(request).

And here your pull stops, and waits,
for AI to finish, you are awaiting an AI funcion.

Only when the AI replies with a cartoon selfie, or a fierce poem,
can you now send it back to the users account.

Don’t call it push, we just send it there,
it is an inbox.

And now that the async for loop body,
which is 3 lines of code, exited, the for loop give you the next request.

Pulls the next request from the warehouse,
from the queue.

All of this can be 15 or 20 lines of code,
when I interact with my AI I just treat failure as a reason to click resend.

So you may not even need a log file,
crash early, and make sure your users have a convenient resend button.

---

I am not allowed to write anymore on the subject,
because I worry I would over complicate it.

This text, the precious spells of [push and pull][1] programming,
must end here, the eureka moment comes later, enjoy.

[1]: files/example.js
